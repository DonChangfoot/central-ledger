"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var AssertionError_1 = require("./AssertionError");
var os_1 = require("os");
require('jake');
function toStringArray(value) {
    if (typeof value === 'string') {
        return [value];
    }
    return value;
}
function assertErrorMessages(msg, expectedErrorMessage, rejectFn) {
    var expectedErrorMessages = toStringArray(expectedErrorMessage);
    var errors = [];
    if (expectedErrorMessages && expectedErrorMessages.length > 0) {
        expectedErrorMessages.forEach(function (expectedEntry) {
            if (!msg.includes(expectedEntry)) {
                errors.push("Expected error to include \"" + expectedEntry + "\", but it was actually \"" + msg + "\"");
            }
        });
    }
    if (errors.length > 0) {
        rejectFn(new AssertionError_1.AssertionError(errors.join('\n')));
    }
}
function assertOutput(stdout, expectedOutput, rejectFn) {
    var expectedOutputs = toStringArray(expectedOutput);
    var errors = [];
    if (expectedOutputs && expectedOutputs.length > 0) {
        expectedOutputs.forEach(function (expectedEntry) {
            if (!stdout.includes(expectedEntry)) {
                errors.push("Expected output to include \"" + expectedEntry + "\", but it was actually \"" + stdout + "\"");
            }
        });
    }
    if (errors.length > 0) {
        rejectFn(new AssertionError_1.AssertionError(errors.join('\n')));
    }
}
function assertNotOutput(stdout, notExpectedOutput, rejectFn) {
    var notExpectedOutputs = toStringArray(notExpectedOutput);
    var errors = [];
    if (notExpectedOutputs && notExpectedOutputs.length > 0) {
        notExpectedOutputs.forEach(function (notExpectedEntry) {
            if (stdout.includes(notExpectedEntry)) {
                errors.push("Expected output not to include \"" + notExpectedEntry + "\", but it was actually \"" + stdout + "\"");
            }
        });
    }
    if (errors.length > 0) {
        rejectFn(new AssertionError_1.AssertionError(errors.join('\n')));
    }
}
/**
 * Execute given commandline command
 */
function execCommand(cliCommand, _a) {
    var _b = _a === void 0 ? {} : _a, description = _b.description, expectedErrorMessage = _b.expectedErrorMessage, expectedOutput = _b.expectedOutput, notExpectedOutput = _b.notExpectedOutput;
    description = description || cliCommand;
    return new Promise(function (resolve, reject) {
        var stderr = '';
        var stdout = '';
        var bin = jake.createExec([cliCommand]);
        bin.addListener('error', function (msg, _code) {
            // Error is expected
            if (expectedErrorMessage) {
                assertErrorMessages(msg, expectedErrorMessage, reject);
                return resolve({ stdout: stdout, stderr: stderr });
            }
            // Error is not expected
            return reject(Error(description + " -> FAIL. " + os_1.EOL + "Stdout: " + stdout + " " + os_1.EOL + "Error: " + stderr));
        });
        bin.addListener('cmdEnd', function (_cmd) {
            if (expectedErrorMessage) {
                throw new AssertionError_1.AssertionError('Error was expected, but none thrown');
            }
            if (expectedOutput) {
                assertOutput(stdout, expectedOutput, reject);
                return resolve({ stdout: stdout, stderr: stderr });
            }
            if (notExpectedOutput) {
                assertNotOutput(stdout, notExpectedOutput, reject);
                return resolve({ stdout: stdout, stderr: stderr });
            }
            return resolve({ stdout: stdout, stderr: stderr });
        });
        bin.addListener('stdout', function (data) { return (stdout += data.toString()); });
        bin.addListener('stderr', function (data) { return (stderr += data.toString()); });
        bin.run();
    });
}
exports.execCommand = execCommand;
//# sourceMappingURL=execution-test-helper.js.map