"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var del = tslib_1.__importStar(require("del"));
var rimraf_1 = require("rimraf");
var path_1 = tslib_1.__importDefault(require("path"));
var fs_1 = tslib_1.__importDefault(require("fs"));
var globule = tslib_1.__importStar(require("globule"));
var FileTestHelper = /** @class */ (function () {
    function FileTestHelper(basePath) {
        if (basePath === void 0) { basePath = './'; }
        this.filesToCleanup = [];
        this.fileGlobsToCleanup = [];
        this.basePath = basePath;
    }
    FileTestHelper.prototype.fileExists = function (filePath) {
        var targetPath = path_1.default.resolve(this.basePath, filePath);
        return fs_1.default.existsSync(targetPath);
    };
    FileTestHelper.prototype.fileGlobExists = function (fileGlobPath) {
        return globule.find(fileGlobPath).length;
    };
    FileTestHelper.prototype.getFileTextContent = function (filePath) {
        var targetPath = path_1.default.resolve(this.basePath, filePath);
        return fs_1.default.readFileSync(targetPath).toString();
    };
    FileTestHelper.prototype.getFileGlobTextContent = function (fileGlobPath) {
        return globule.find(fileGlobPath).map(function (resolvedPath) {
            return fs_1.default.readFileSync(resolvedPath).toString();
        });
    };
    FileTestHelper.prototype.deleteFile = function (filePath, _a) {
        var _b = (_a === void 0 ? {} : _a).isPathAbsolute, isPathAbsolute = _b === void 0 ? false : _b;
        var targetPath = isPathAbsolute ? filePath : path_1.default.resolve(this.basePath, filePath);
        if (fs_1.default.existsSync(targetPath)) {
            fs_1.default.unlinkSync(targetPath);
        }
    };
    FileTestHelper.prototype.deleteFileGlob = function (fileGlobPath) {
        del.sync(fileGlobPath);
    };
    /**
     * Create file and (optionally) register it for later cleanup
     */
    FileTestHelper.prototype.createFile = function (filePath, fileContent, _a) {
        var _b = _a === void 0 ? {} : _a, _c = _b.willBeCleanedUp, willBeCleanedUp = _c === void 0 ? true : _c, _d = _b.isPathAbsolute, isPathAbsolute = _d === void 0 ? false : _d;
        if (willBeCleanedUp) {
            this.registerForCleanup(filePath, { isPathAbsolute: isPathAbsolute });
        }
        var targetPath = isPathAbsolute ? filePath : path_1.default.resolve(this.basePath, filePath);
        mkDirByPathSync(path_1.default.dirname(targetPath));
        fs_1.default.writeFileSync(targetPath, fileContent);
    };
    /**
     * Add path to a file that should be deleted after calling cleanup command
     */
    FileTestHelper.prototype.registerForCleanup = function (filePath, _a) {
        var _b = (_a === void 0 ? {} : _a).isPathAbsolute, isPathAbsolute = _b === void 0 ? false : _b;
        var targetPath = isPathAbsolute ? filePath : path_1.default.resolve(this.basePath, filePath);
        this.filesToCleanup.push(targetPath);
    };
    /**
     * Add glob path to a file that should be deleted after calling cleanup command
     */
    FileTestHelper.prototype.registerGlobForCleanup = function (fileGlobPath) {
        this.fileGlobsToCleanup.push(fileGlobPath);
    };
    /**
     * Delete all files that were created by this helper or explicitly added to cleanup list
     */
    FileTestHelper.prototype.cleanup = function () {
        this.filesToCleanup.forEach(function (filePath) {
            rimraf_1.sync(filePath);
        });
        this.fileGlobsToCleanup.forEach(function (fileGlob) {
            del.sync(fileGlob);
        });
    };
    return FileTestHelper;
}());
exports.FileTestHelper = FileTestHelper;
function mkDirByPathSync(targetDir, _a) {
    var _b = (_a === void 0 ? {} : _a).isRelativeToScript, isRelativeToScript = _b === void 0 ? false : _b;
    var sep = path_1.default.sep;
    var initDir = path_1.default.isAbsolute(targetDir) ? sep : '';
    var baseDir = isRelativeToScript ? __dirname : '.';
    return targetDir.split(sep).reduce(function (parentDir, childDir) {
        var curDir = path_1.default.resolve(baseDir, parentDir, childDir);
        try {
            fs_1.default.mkdirSync(curDir);
        }
        catch (err) {
            if (err.code === 'EEXIST') {
                // curDir already exists!
                return curDir;
            }
            // To avoid `EISDIR` error on Mac and `EACCES`-->`ENOENT` and `EPERM` on Windows.
            if (err.code === 'ENOENT') {
                // Throw the original parentDir error on curDir `ENOENT` failure.
                throw new Error("EACCES: permission denied, mkdir '" + parentDir + "'");
            }
            var caughtErr = ['EACCES', 'EPERM', 'EISDIR'].indexOf(err.code) > -1;
            if (!caughtErr || (caughtErr && curDir === path_1.default.resolve(targetDir))) {
                throw err; // Throw if it's just the last created dir.
            }
        }
        return curDir;
    }, initDir);
}
//# sourceMappingURL=FileTestHelper.js.map